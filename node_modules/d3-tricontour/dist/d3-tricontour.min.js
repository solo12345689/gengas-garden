// https://github.com/Fil/d3-tricontour v1.1.0 Copyright 2025 Philippe Rivi√®re
!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports,require("d3-delaunay"),require("d3-scale")):"function"==typeof define&&define.amd?define(["exports","d3-delaunay","d3-scale"],n):n((t="undefined"!=typeof globalThis?globalThis:t||self).d3=t.d3||{},t.d3,t.d3)}(this,function(t,n,e){"use strict";function o(t){return Array.from(function*(t){for(const n of t)yield*n}(t))}function r(t,n){const e=n.length;let o=-1;for(;++o<e;){const e=i(t,n[o]);if(e)return e}return 0}function i(t,n){let e=n[0],o=n[1],r=-1;for(let i=0,f=t.length,l=f-1;i<f;l=i++){const f=t[i],c=f[0],s=f[1],a=t[l],d=a[0],h=a[1];if(u(f,a,n))return 0;s>o!=h>o&&e<(d-c)*(o-s)/(h-s)+c&&(r=-r)}return r}function u(t,n,e){let o;return function(t,n,e){return(n[0]-t[0])*(e[1]-t[1])===(e[0]-t[0])*(n[1]-t[1])}(t,n,e)&&(r=t[o=+(t[0]===n[0])],i=e[o],u=n[o],r<=i&&i<=u||u<=i&&i<=r);var r,i,u}function f(t){let n=0,e=t.length,o=t[e-1][1]*t[0][0]-t[e-1][0]*t[0][1];for(;++n<e;)o+=t[n-1][1]*t[n][0]-t[n-1][0]*t[n][1];return o}function l(t){const n=[],e=[];for(const o of t)f(o)>0?n.push([o]):e.push(o);return e.forEach(function(t){for(let e,o=0,i=n.length;o<i;++o)if(-1!==r((e=n[o])[0],t))return void e.push(t)}),n}t.tricontour=function(){let t,r,i,u=t=>t[0],f=t=>t[1],c=t=>isFinite(+t[2])?+t[2]:0,s=n.Delaunay.from,a=(t,n,e)=>{const{points:o}=i,r=[o[2*t],o[2*t+1]],u=[o[2*n],o[2*n+1]];return[e*u[0]+(1-e)*r[0],e*u[1]+(1-e)*r[1]]},d=l;function h(n){i=s(n,u,f),r=Array.from(n,c),"object"!=typeof t&&(t=e.scaleLinear().domain(function(t){let n,e;for(const o of t)null!=o&&(void 0===n?o>=o&&(n=e=o):(n>o&&(n=o),e<o&&(e=o)));return[n,e]}(r)).nice().ticks(t))}function*p(n){h(n);for(const n of t){const t=m(i,r,n);yield{type:"MultiPolygon",coordinates:t,value:n}}}const g=function(t){return[...p(t)]};return g.x=t=>t?(u=t,g):u,g.y=t=>t?(f=t,g):f,g.value=t=>t?(c=t,g):c,g.thresholds=n=>n?(t=n,g):t,g.triangulate=t=>t?(s=t,g):s,g.pointInterpolate=t=>t?(a=t,g):a,g.ringsort=t=>t?(d=t,g):d,g.contours=p,g.contour=function(t,n){return h(t),{type:"MultiPolygon",coordinates:m(i,r,n),value:n}},g.isobands=function*(n){let e,u,f;h(n);for(const n of t)u&&(e=u),u=o(m(i,r,n)),e&&(yield{type:"MultiPolygon",coordinates:d(e.concat(u.map(t=>t.slice().reverse()))),value:f,valueMax:n}),f=n},g._values=()=>r,g._triangulation=()=>i,g;function y(t){return t%3==2?t-2:t+1}function v(t){return t%3==0?t+2:t-1}function m(t,n,e=0){for(const t of n)if(!isFinite(t))throw["Invalid value",t];const{halfedges:o,inedges:r,triangles:i}=t,u=n.length,f=new Map;function l(t){return c(i[t],i[y(t)])}function c(t,o){const r=n[t],i=n[o];if(r<=e&&i>=e&&r<i)return(e-r)/(i-r)}o.forEach((t,n)=>{-1===t&&f.set(i[n],i[n+(n%3==2?-2:1)])});const s=[],h=new Uint8Array(o.length).fill(0);let p,g,m,j,b;for(j=0;j<o.length;j++)if(!h[j]){for(g=j,p=[];(b=l(g))>0;){const[t,s]=[i[g],i[m=y(g)]];if(p.length&&t===p[0].ti&&s===p[0].tj||p.length>2*u)break;if(h[g]=1,p.push({ti:t,tj:s,a:b}),(m=o[g])>-1){if(l(m=y(m))>0){g=m;continue}if(l(m=y(m))>0){g=m;continue}}else{let t=i[g];for(;n[t]<e;)t=f.get(t);for(;n[t]>=e;)p.push({ti:t,tj:t,a:0}),t=f.get(t);if(m=r[t],p.push({ti:t,tj:i[m],a:c(t,i[m])}),l(g=y(m))>0)continue;if(l(g=v(m))>0)continue}}p.length&&(p.push(p[0]),s.push(p.map(({ti:t,tj:n,a:e})=>a(t,n,e))))}do{const t=[];let o=f.keys().next().value;do{const n=f.get(o);t.push(o),f.delete(o),o=n}while(f.has(o));t.every(t=>n[t]>=e)&&(t.push(t[0]),s.push(t.map(t=>a(t,t,0))))}while(f.size);return d(s)}},Object.defineProperty(t,"__esModule",{value:!0})});
